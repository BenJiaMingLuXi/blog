<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java基础笔记核心卷一</title>
      <link href="/newblog/2020/10/07/java-xue-xi-bi-ji-1/"/>
      <url>/newblog/2020/10/07/java-xue-xi-bi-ji-1/</url>
      
        <content type="html"><![CDATA[<p>百度了applet含义 java语言编写的小程序，HTML全称 Hyper Text Markup(标记)  Language ，超文本标记语言，oriented 面向 ，OOP（Object-Oriented Programming）面向对象编程，GUI(Graphical User Interface)图形用户接口</p><p>2020年10月12日23:14:26</p><p>百度了尾数。\u转义可以不在‘ ’和“ ”之中， unicode编码和中文互转System.out.println(“\u6211\u7231\u4f60”); 除数，被除数，8被32除 .？8（被除数）/32（除数）</p><p>2020年10月13日21:01:57</p><p> 位运算符看不懂 操作数只能是整型和字符型</p><p>&amp; 位于运算 0&amp;0=0，1&amp;0=0,1&amp;1=1,0&amp;1=0</p><p>| 位或运算 0|0=0,0|1=1,1|1=1.1|0=1</p><p>^异或运算 1^0=1,1^1=0,0^0=0,0^1=1</p><p>百度补码，计算机中的有符号数有三种表示方法，原码，反码，补码。在计算机系统中，数值均采用补码表示和存储，因为可以将符号位和数值域统一处理。</p><p>原码：符号位+真值绝对值</p><p>反码：正数反码是本身，负数反码：符号位不变，其余位取反</p><p>补码：正数补码是本身，负数补码：反码+1</p><p>机器数：一个数在计算机中的二进制表现形式。带符号位</p><p>真值：十进制正数</p><p>2020年10月17日22:44:26</p><p>代码点：unicode为字符分配的编号，一个代码只占一个代码点却不一定只占一个代码单元</p><p>代码单元:编码方法中对一个字符编码后所占最小的存储单元，utf-8中代码单元就是一个字节，因为一个字符可以被编码成一个字节，两个字节或3,4个字节。utf-16中代码单元就是两个字节（一个char）</p><p>2020年10月19日20:00:25</p><p>java.lang 包是java语言的核心，他提供了java中的基础类。</p><p>bounds(界限范围)   cast(模 n.)</p><p>断言:布尔表达，关键字 assert,两种形式 assert Exception1 ,assert Exception1;Exception2 ,其中Exception1总是1个布尔表达式，Exception2是断言失败输出的字符串，如果E1为假，则抛出一个AssertError这是一个错误，而不是异常，也就是一个unchecked Exception (不可控制异常)，所以不推荐捕获，因为会导致你的系统进入不稳定状态。编译时启用断言使用source1.4标记，即java source1.4 Test.java,运行时启用断言使用-ea参数。要在系统类中启用断言可以使用-esa和-eda参数</p><p>java object类（?）</p><p>CharSequence形参（接口） 完全类似String类型的实参</p><p>this.x=x  解读：成员变量：类内，方法外。局部变量：方法内，包含参数。this.成员相关</p><p>System.exit(0);正常退出程序，结束jvm。System.exit(非0)非正常退出，一般用在catch块中，捕获异常结束程序时。</p><p>2020年10月20日22:21:51</p><p>shell(?) DOS（？）命令提示符（）ini文件（？）</p><p>绝对路径：硬盘上的真正路径，相对路径：/表示根目录 ，./ 表示当前目录 ， ../ 表示上级目录 </p><p>轻量级：组件对环境的依赖程度 越小越轻</p><p>奇怪的知识：拉丁字母（罗马字母）10.20 toby里面没看</p><p>2020年10月21日20:00:40</p><p>System.out.printf()打印标志</p><p>2020年10月22日19:26:03</p><p>java标注 是对编译器或者处理java源文件或者类文件的工具提供信息的一种机制@SuperessWarnings(“fallthrough”),如果想警告使用直通式行为，加这个标注就不会对这个方法生成警告</p><p>枚举类型（？）</p><p>显示转换：表示范围大的类型转化为表示范围小的类型</p><p>隐式转换:范围小的类型转换为范围大的类型，也叫自动转换</p><p>compatible 兼容的</p><p>continue 和break</p><p>2020年10月23日19:05:33</p><p>2020年10月26日18:18:46</p><p>decimal 小数 , binomial 二项 , coefficient 系数， 如果需要在运行过程中扩展数组大小 使用ArrayList 数据结构,数组长度为0和null不同 ，大多数为0和Null好像都不同</p><p>2020年10月27日17:54:08</p><p>printf(“%8.2f”,a);用8个字符宽度和小数点后2位两个字符的精度打印a。System.out.printf(“%.0f%%”,a);  输出%必要前面要带格式</p><p>2020年10月28日17:54:36</p><p>allocate 分配  ，triangulat 三角，lottery 彩票， odds 几率,construct构造 ，instance 实例</p><p>类 构造 对象 的过程称为 创建类的实例。</p><p>2020年10月29日20:01:22</p><p>商品被添加到订单中 ： 找名词和动词 ，确定order （订单）类中有add方法，其中item对象（商品）是一个参数。</p><p>unified 统一，</p><p>Date birthday = new Date();    对象指的是 new Date(), 其中 Date是构造器名字，并且它的值是新创建对象的引用，且这个引用存储在对象变量birthday中，birthday 是对象变量，但是它不是对象，而且对象变量并没有实际包含一个对象，仅仅是引用，对象的引用指的是 birthday,</p><p>2020年10月30日20:04:47</p><p>mutator method 更改器方法，access method 访问器方法，在java中这两种在语法上没有明显区别</p><p>LocalDate类 中的minusDays(int n)方法的参数是LocalDate 减去的天数，意思是当前日期的前n天，如果minusDays(today - 1),就是today - today +1,意为 1号，</p><p>plusDays(int n)当前日期的后n天</p><p>再次记记 %2d, 前面补齐空格 占够两个字符。</p><p>2020年11月1日18:39:24</p><p>2020年11月2日20:03:10</p><p>源文件名必须与public类的名字相匹配。在源文件中只能有一个公有类（public修饰）,可以有任意数目的非公有类。</p><p>Unix的make工具，windows的nmake工具，可以认为java编译器内置了make功能（？）</p><p>所有java对象都是在堆中构造的，且构造器总是伴随的new操作符一起调用的</p><p>redundant 冗余的</p><p>在所有的地方不要命名与实例域同名的变量,因为这些变量屏蔽了同名的实例域：public Employee</p><p>{</p><p>private String name;</p><p>private double salary;</p><p>private LocalDate hireday;</p><p>public Employee(String n,double s,int year,int month,int day)</p><p>​    {</p><p>​        String name = n;// error</p><p>​        double salary = s;//error</p><p>​     } </p><p>public void raiseSalary(double byPersent)</p><p>​            {</p><p>​                double raise = salary*byPersent/100;</p><p>​                salary+=raise;</p><p>​            }</p><p>}</p><p>implicit 隐式的，explicit显示的，隐式参数（方法调用的目标或接收者）是方法名前的类对象，没有·出现在方法的声明中。显示参数是方法名后面括号内的数值，出现在方法的声明中。</p><p>前面讲的this关键字，就是表示隐式参数，如果需要的话可以用如下方法写raiseSalary方法</p><p>double raise = this.salary*byPersent/100;</p><p>this.salary+=raise;</p><p>因为这样可以将实例域与局部变量区分开来。</p><p>在java，所有的方法都必须在类的内部定义，但并不表示它们都是内联方法。是否将某个方法设置为内联方法是java虚拟机的任务，及时编译器会监视调用那些简洁、经常使用、没有被重载以及可优化的方法。</p><p>seniority 级别高，年长，</p><p>不要编写返回引用 可变对象 的访问器方法。见Test2.java</p><p>产生疑问？方法调用对象还是对象调用方法。按理说应该是对象调用方法。但是 有句话很难理解 </p><p>方法可以访问所调用对象的私有数据。这句话表面上就是方法调用对象。好 这个问题不是这句话的关键点，先不考虑这个问题，关键是 test类中的方法可以访问test类任何一个对象的私有域。</p><p>2020年11月3日19:59:49</p><p>primitive 基本的原始的，immutable 不可变的。final 修饰符 修饰基本类和不可变类的域。见4.3.9加了final不能Set，初始化之后不能修改。  </p><p>不可变类 ：类中的每个方法不会改变其对象，例如String类。</p><p>private int id ;private static int nextId; 1000类对象有1000个id，但只有一个nextId，换言之nextId属于类不属于对象。而且每个类只能有一个这样的域。在绝大多数的面向对象编程语言中，静态域也叫类域</p><p> public void setId(){id = nextId; nextId++;}  假定harry.setId();   上述代码类似harry.id=Employee.nextId; Employee.nextId++;</p><p>静态常量 ：public class Math{public static final double PI =3.14159265358979323846;} Math.PI获得这个常量。</p><p>public class System{public static final PrintStream out;…}   System.out使用 </p><p>前面提到过每个类对象会对公有域进行修改，但是公有常量，final 域没问题，因为一旦初始化赋值之后不能修改。</p><p>System类中有一个setOut方法，它可以将System.out设置为不同的流， 问题来了，他为什么可以改变final变量的值 ，因为它是一个本地方法，java本地方法会绕过JAVA语言的存取控制机制。在自己编写程序时不应该这样处理。</p><p>静态方法：不能面向对象的实施操作方法，不使用对象，话句话说没有隐式参数，也就是没有this参数。静态方法不能访问实例域，但是可以访问本类的静态域。类名调用这个静态方法。</p><p>下面这两种方法使用静态方法：1、不需要放访问对象状态，其所需参数都是显示参数。2、只需要访问类的静态域</p><p>静态方法还有另一种用途，静态工厂方法 factory method 来构造对象，如类 LcoalDate和NumberFormat ，见4.4.4</p><p>current 当前的，</p><p>2020年11月4日20:24:15</p><p>每一个类可以有一个main方法，Idea 里面我写的代码都是单元测试.见idea</p><p>如果独立测试test类，只需执行 java test 。如果test类是一个更大型应用程序的一部分，就可以使用 java Application ，test类的main方法就不会执行 ,见idea 中的StaticTest.java</p><p>见4.5上面一点点   java Employee  和 java StaticTest 的区别 （？？）见idea StaticTest.java #在上面</p><p> 方法参数：回忆一下有关将参数传递给函数或方法的专业术语。按值调用（call by value ）:即方法接收的是调用者提供的值；按引用调用（call by reference）方法接收的是调用者提供的变量的地址。</p><p>方法可以修改传递引用所对应的变量值，但是不能修改传递值调用所对应的变量值。</p><p>java程序设计语言总是采用按值调用的，方法得到的是所有参数值得一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。ex:double a =10; harry.raiseSalary(a);  不必理睬方法的具体实现，方法调用后，a 还是10。</p><p>2020年11月5日20:20:00</p><p>方法参数共有两种类型：基本数据类型（数字，布尔值）和 对象引用。上述已经知道 一个方法不能修改一个基本数据类型的参数，但对象引用作为参数就不同了。</p><p>idea中 T4.java证明了java不是按引用调用的。实际上 对象引用是按值调用的。</p><p>总结一下java中方法参数的使用情况：1、方法不能修改基本数据类型的参数。2、方法可以改变对象参数的状态。3、方法中不能让对象参数 引用一个新对象。 见 T4.java.</p><p>modify 修改，triple 三倍的</p><p>从现在在 idea中注意 注释的书写。见ParamTest.java</p>]]></content>
      
      
      <categories>
          
          <category> java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>靶场练习</title>
      <link href="/newblog/2020/10/07/ba-chang-lian-xi-1/"/>
      <url>/newblog/2020/10/07/ba-chang-lian-xi-1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> hac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这是写的测试博客~~</title>
      <link href="/newblog/2020/09/22/my-first-blog/"/>
      <url>/newblog/2020/09/22/my-first-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="这是写的测试文档"><a href="#这是写的测试文档" class="headerlink" title="这是写的测试文档"></a>这是写的测试文档</h1><p>测试显示博客内容 <del>~</del></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/newblog/2020/09/22/hello-world/"/>
      <url>/newblog/2020/09/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
